<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>师傅打妖怪啦</title>
  
  
  <link href="https://cxmblog.top/atom.xml" rel="self"/>
  
  <link href="https://cxmblog.top/"/>
  <updated>2022-06-20T15:14:44.600Z</updated>
  <id>https://cxmblog.top/</id>
  
  <author>
    <name>CXM</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信退款V3版本</title>
    <link href="https://cxmblog.top/2022/06/17/%E5%BE%AE%E4%BF%A1%E9%80%80%E6%AC%BEV3%E7%89%88%E6%9C%AC/"/>
    <id>https://cxmblog.top/2022/06/17/%E5%BE%AE%E4%BF%A1%E9%80%80%E6%AC%BEV3%E7%89%88%E6%9C%AC/</id>
    <published>2022-06-17T13:26:26.961Z</published>
    <updated>2022-06-20T15:14:44.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微信退款V3版本"><a href="#微信退款V3版本" class="headerlink" title="微信退款V3版本"></a>微信退款V3版本</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">微信官方文档：https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_1_9.shtml</span><br></pre></td></tr></table></figure><h2 id="环境说明："><a href="#环境说明：" class="headerlink" title="环境说明："></a>环境说明：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring版本：4.1.7.RELEASE</span><br><span class="line">jdk版本：1.8</span><br><span class="line">maven版本：3.8.5</span><br></pre></td></tr></table></figure><p><code>可能需要用的依赖，如果实际运行提示缺少什么包中的的什么方法，就去maven仓库中下载，我也是一点一点摸着过来的</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.github.wechatpay-apiv3&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;wechatpay-apache-httpclient&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;0.4.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;5.8.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jackson-core&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.13.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.13.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.13.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">微信支付商户号：merchantId</span><br><span class="line">商户API证书序列号：merchantSerialNumber</span><br><span class="line">商户API私钥地址：merchantPrivateKeyPath</span><br><span class="line">商户apiV3秘钥：apiV3Key</span><br><span class="line"></span><br><span class="line">这四个参数是必须的，需要设置为全局变量，会在退款方法跟回调方法中做双向验签时使用。具体如何获得四个参数参看微信支付文档即可</span><br><span class="line"></span><br><span class="line">证书管理器： certificatesManager，该参数需要设置为全局变量，在退款方法中会下载证书并储存在这个对象中，然后在回调方法中会使用这个对象得到验证器去做验证</span><br><span class="line"> <span class="type">CertificatesManager</span> <span class="variable">certificatesManager</span> <span class="operator">=</span> CertificatesManager.getInstance();</span><br></pre></td></tr></table></figure><p><code>我写的demo使用的是微信官方提供的sdk : wechatpay-apache-httpclient</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay6_0.shtml</span><br><span class="line">wechatpay-apache-httpclient，适用于使用Apache HttpClient处理HTTP的Java开发者。</span><br></pre></td></tr></table></figure><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="1，按文档中请求参数要求，获得需要的参数信息"><a href="#1，按文档中请求参数要求，获得需要的参数信息" class="headerlink" title="1，按文档中请求参数要求，获得需要的参数信息"></a>1，按文档中请求参数要求，获得需要的参数信息</h3><p>（我只填写了必填项以及回调参数，其他参数请按实际需求填写）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@RequestMapping(&quot;/XXXXXXXXXX&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> JSONObject <span class="title function_">acquireWXParams</span><span class="params">(Long reservationId)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> acquireWXParams(reservationId, refundNotify);</span><br><span class="line">  &#125;</span><br><span class="line">  ---------------------华丽的分界线-------------------------</span><br><span class="line">   <span class="keyword">public</span> JSONObject <span class="title function_">acquireWXParams</span><span class="params">(Long reservationId, String refundNotify)</span> &#123;</span><br><span class="line">      <span class="comment">//储存微信退款所需要的参数</span></span><br><span class="line">      Map&lt;String, Object&gt; wxParams = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">      <span class="comment">//获取微信支付订单号</span></span><br><span class="line">      <span class="keyword">if</span>(reservationId == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> resultJSON(<span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//根据reservation获取预定信息实例</span></span><br><span class="line">      <span class="comment">//此处为查询数据库操作，我需要根据预订信息表中的数据得到相应的参数，具体参数获得请按照实际项目需要填写</span></span><br><span class="line">      <span class="type">ReservationInformation</span> <span class="variable">reservation</span> <span class="operator">=</span> reservationInformationDao.get(reservationId);</span><br><span class="line">      <span class="keyword">if</span>(reservation == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> resultJSON(<span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//获取微信支付订单号</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">transaction_id</span> <span class="operator">=</span> reservation.getOrderMchid();</span><br><span class="line">      <span class="keyword">if</span>(transaction_id == <span class="literal">null</span> || transaction_id.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">return</span> resultJSON(<span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//生成商户退款单号</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">refundNumber</span> <span class="operator">=</span> <span class="string">&quot;RM_TK&quot;</span>+System.currentTimeMillis();</span><br><span class="line">      <span class="comment">//获得金额信息(包括退款金额，原订单金额，退款币种)</span></span><br><span class="line">      Map&lt;String, Object&gt; amount = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">      <span class="comment">//退款金额</span></span><br><span class="line">      <span class="type">BigDecimal</span> <span class="variable">bigDecimal</span> <span class="operator">=</span> reservation.getPrice();</span><br><span class="line">      <span class="keyword">if</span>(bigDecimal == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> resultJSON(<span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//微信需要的该参数单位是分，所以乘以100</span></span><br><span class="line">      <span class="type">long</span> <span class="variable">refund</span> <span class="operator">=</span> bigDecimal.longValue() * <span class="number">100</span>;</span><br><span class="line">      <span class="comment">//原订单金额</span></span><br><span class="line">      <span class="comment">//我们不做一笔订单多次退款，只做一次退全款，所以退款金额跟原订单金额相同</span></span><br><span class="line">      <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> refund;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//金额信息设置-----开始</span></span><br><span class="line">      amount.put(<span class="string">&quot;refund&quot;</span>, refund);</span><br><span class="line">      amount.put(<span class="string">&quot;total&quot;</span>, total);</span><br><span class="line">      amount.put(<span class="string">&quot;currency&quot;</span>, <span class="string">&quot;CNY&quot;</span>);</span><br><span class="line">      <span class="comment">//金额信息设置-----结束</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//返回参数设置-----开始</span></span><br><span class="line">      <span class="comment">//微信支付订单号</span></span><br><span class="line">      wxParams.put(<span class="string">&quot;transaction_id&quot;</span>, transaction_id);</span><br><span class="line">      <span class="comment">//商户退款单号</span></span><br><span class="line">      wxParams.put(<span class="string">&quot;out_refund_no&quot;</span>, refundNumber);</span><br><span class="line">      <span class="comment">//金额信息</span></span><br><span class="line">      wxParams.put(<span class="string">&quot;amount&quot;</span>, amount);</span><br><span class="line">      <span class="comment">//回调路径</span></span><br><span class="line">      wxParams.put(<span class="string">&quot;notify_url&quot;</span>, refundNotify);</span><br><span class="line">      <span class="comment">//返回参数设置-----结束</span></span><br><span class="line">      <span class="keyword">return</span> resultJSON(<span class="literal">true</span>, wxParams);</span><br><span class="line">  &#125;</span><br><span class="line">   ---------------------华丽的分界线-------------------------</span><br><span class="line">   <span class="keyword">public</span> JSONObject <span class="title function_">resultJSON</span><span class="params">(<span class="type">boolean</span> isRight, Object data)</span> &#123;</span><br><span class="line">      <span class="type">JSONObject</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">      json.put(<span class="string">&quot;result&quot;</span>, isRight);</span><br><span class="line">      <span class="keyword">if</span>(data != <span class="literal">null</span>) &#123;</span><br><span class="line">          json.put(<span class="string">&quot;data&quot;</span>, data);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> json;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="2，接下来拿着上面得到的退款接口所需要的全部参数，向微信退款接口发起post请求"><a href="#2，接下来拿着上面得到的退款接口所需要的全部参数，向微信退款接口发起post请求" class="headerlink" title="2，接下来拿着上面得到的退款接口所需要的全部参数，向微信退款接口发起post请求"></a>2，接下来拿着上面得到的退款接口所需要的全部参数，向微信退款接口发起post请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@RequestMapping(&quot;/XXXXXXXXXX&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">WXRefundApi</span><span class="params">(String wxparams)</span> &#123;<span class="comment">//wxparams即为微信退款接口所需要的数据了，就是将上边json格式的数据转换为String格式（我当时脑子可能不太好使，得到参数后向js响应，然后再用js再带着参数再请求这个接口）</span></span><br><span class="line">   <span class="comment">//merchantPrivateKeyPath = &quot;/apiclient_key.pem&quot;</span></span><br><span class="line">   <span class="comment">//我是将私钥商户API私钥放在了resource中，所以我可以读到该文件的内容，大家的私钥文件根据项目实际情况放置即可，只要能够读到文件内容即可</span></span><br><span class="line">   <span class="comment">//也可以将私钥中的内容复制出来，存在一个字符串中，直接读这个字符串也行，wechatpay-apache-httpclient这个sdk的 README.md中也有写到：</span></span><br><span class="line">   <span class="comment">//# 示例：私钥为String字符串</span></span><br><span class="line"><span class="comment">/**PrivateKey merchantPrivateKey = PemUtil.loadPrivateKey(</span></span><br><span class="line"><span class="comment">     new ByteArrayInputStream(privateKey.getBytes(&quot;utf-8&quot;)));*/</span></span><br><span class="line">     <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(merchantPrivateKeyPath).getInputStream()) &#123;</span><br><span class="line">         <span class="type">PrivateKey</span> <span class="variable">merchantPrivateKey</span> <span class="operator">=</span> PemUtil.loadPrivateKey(is);</span><br><span class="line">         certificatesManager = CertificatesManager.getInstance();</span><br><span class="line">         <span class="comment">// 向证书管理器增加需要自动更新平台证书的商户信息</span></span><br><span class="line">         certificatesManager.putMerchant(merchantId, <span class="keyword">new</span> <span class="title class_">WechatPay2Credentials</span>(merchantId, <span class="keyword">new</span> <span class="title class_">PrivateKeySigner</span>(merchantSerialNumber, merchantPrivateKey)), apiV3Key.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">         <span class="comment">// 从证书管理器中获取verifier</span></span><br><span class="line">         <span class="type">Verifier</span> <span class="variable">verifier</span> <span class="operator">=</span> certificatesManager.getVerifier(merchantId);</span><br><span class="line">         <span class="type">WechatPayHttpClientBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> WechatPayHttpClientBuilder.create()</span><br><span class="line">                 .withMerchant(merchantId, merchantSerialNumber, merchantPrivateKey)</span><br><span class="line">                 .withValidator(<span class="keyword">new</span> <span class="title class_">WechatPay2Validator</span>(verifier));</span><br><span class="line">         <span class="comment">// 通过WechatPayHttpClientBuilder构造的HttpClient，会自动的处理签名和验签</span></span><br><span class="line">         <span class="keyword">try</span> (<span class="type">CloseableHttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> builder.build()) &#123;</span><br><span class="line">             <span class="type">HttpPost</span> <span class="variable">httpPost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(<span class="string">&quot;https://api.mch.weixin.qq.com/v3/refund/domestic/refunds&quot;</span>);</span><br><span class="line">             httpPost.addHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">             httpPost.addHeader(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/json; charset=utf-8&quot;</span>);</span><br><span class="line">             httpPost.setEntity(<span class="keyword">new</span> <span class="title class_">StringEntity</span>(wxparams));</span><br><span class="line">             <span class="type">CloseableHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> httpClient.execute(httpPost);</span><br><span class="line"><span class="comment">//这就是请求微信退款接口得到的响应数据</span></span><br><span class="line">             <span class="type">String</span> <span class="variable">bodyAsString</span> <span class="operator">=</span> EntityUtils.toString(response.getEntity());</span><br><span class="line">             System.out.println(bodyAsString);</span><br><span class="line">           <span class="comment">//接下来就可以按照实际项目逻辑做一些处理</span></span><br><span class="line">           <span class="comment">//。。。。。。。。。。。。。</span></span><br><span class="line">           <span class="comment">//。。。。。。。。。。。。。</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException | GeneralSecurityException | HttpCodeException | NotFoundException e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3，对微信端做出正确的响应"><a href="#3，对微信端做出正确的响应" class="headerlink" title="3，对微信端做出正确的响应"></a>3，对微信端做出正确的响应</h3><p>当我们向微信发起退款请求完成后，微信会调用我们之前填写的回调地址，向我们响应退款结果，如果我们没能正确给微信响应，他会反复请求我们的回调地址，下边是微信的通知规则</p><p><code>通知规则</code></p><p>商户退款完成后，微信会把相关退款结果和用户信息发送给清算机构，清算机构需要接收处理后返回应答成功，然后继续给异步通知到下游从业机构。</p><p>对后台通知交互时，如果微信收到应答不是成功或超时，微信认为通知失败，微信会通过一定的策略定期重新发起通知，尽可能提高通知的成功率，但微信不保证通知最终能成功。（通知频率为15s&#x2F;15s&#x2F;30s&#x2F;3m&#x2F;10m&#x2F;20m&#x2F;30m&#x2F;30m&#x2F;30m&#x2F;60m&#x2F;3h&#x2F;3h&#x2F;3h&#x2F;6h&#x2F;6h - 总计 24h4m）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@RequestMapping(&quot;/XXXXXXXXX&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refundNotify</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;进入回调接口&quot;</span>);</span><br><span class="line">        <span class="comment">//此处设置响应状态码200以及成功的消息仅是为了正确响应微信端，防止微信端反复调用此回调接口</span></span><br><span class="line">      response.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        response.setStatus(<span class="number">200</span>);</span><br><span class="line">        response.getOutputStream().write(mapResult(<span class="string">&quot;SUCCESS&quot;</span>, <span class="string">&quot;成功&quot;</span>));</span><br><span class="line">      response.flushBuffer();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//获得NotificationRequest对象</span></span><br><span class="line">            <span class="type">NotificationRequest</span> <span class="variable">notificationRequest</span> <span class="operator">=</span> getNotificationRequest(request);</span><br><span class="line">            <span class="comment">//获得微信支付通知报文解密结果</span></span><br><span class="line">            <span class="type">Notification</span> <span class="variable">notification</span> <span class="operator">=</span> getParseResult(notificationRequest);</span><br><span class="line">            <span class="comment">//验证通过，确认是微信官方发送的的请求</span></span><br><span class="line">            <span class="comment">//接下来要实现业务逻辑</span></span><br><span class="line">            handle(notification);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ValidationException | NotFoundException | IOException | ParseException e) &#123;</span><br><span class="line">            LOGGER.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;回调结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-----------------------华丽的分割线-----------------------</span><br><span class="line">  <span class="keyword">public</span> <span class="type">byte</span>[] mapResult(String code, String message) &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>, code);</span><br><span class="line">        map.put(<span class="string">&quot;message&quot;</span>, message);</span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toJsonStr(map).getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line">-----------------------华丽的分割线-----------------------</span><br><span class="line">  <span class="keyword">public</span> NotificationRequest <span class="title function_">getNotificationRequest</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//从请求头获取验签字段</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">Timestamp</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Wechatpay-Timestamp&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">Nonce</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Wechatpay-Nonce&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">Signature</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Wechatpay-Signature&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">Serial</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Wechatpay-Serial&quot;</span>);</span><br><span class="line">        <span class="comment">//读取请求体的信息</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> request.getInputStream();</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span>((s = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            sb.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestBody</span> <span class="operator">=</span> String.valueOf(sb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NotificationRequest</span>.Builder().withSerialNumber(Serial)</span><br><span class="line">                .withNonce(Nonce)</span><br><span class="line">                .withTimestamp(Timestamp)</span><br><span class="line">                .withSignature(Signature)</span><br><span class="line">                .withBody(requestBody)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">-----------------------华丽的分割线-----------------------</span><br><span class="line">  <span class="keyword">public</span> Notification <span class="title function_">getParseResult</span><span class="params">(NotificationRequest notificationRequest)</span> <span class="keyword">throws</span> NotFoundException, ValidationException, ParseException &#123;</span><br><span class="line">        <span class="comment">//验签和解析请求体</span></span><br><span class="line">        <span class="comment">// 从证书管理器中获取verifier</span></span><br><span class="line">        <span class="type">Verifier</span> <span class="variable">verifier</span> <span class="operator">=</span> certificatesManager.getVerifier(merchantId);</span><br><span class="line">        <span class="type">NotificationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotificationHandler</span>(verifier, apiV3Key.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">//在解析微信支付通知请求结果时会自动验签，不通过会抛出异常</span></span><br><span class="line">        <span class="keyword">return</span> handler.parse(notificationRequest);</span><br><span class="line">    &#125;</span><br><span class="line">-----------------------华丽的分割线-----------------------</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Notification notification)</span> &#123;</span><br><span class="line">        <span class="comment">//从notification中获取解密报文</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">decryptData</span> <span class="operator">=</span> notification.getDecryptData();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        解密后的明文如下</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">          &quot;mchid&quot;: &quot;1900000100&quot;,</span></span><br><span class="line"><span class="comment">          &quot;transaction_id&quot;: &quot;1008450740201411110005820873&quot;,</span></span><br><span class="line"><span class="comment">          &quot;out_trade_no&quot;: &quot;20150806125346&quot;,</span></span><br><span class="line"><span class="comment">          &quot;refund_id&quot;: &quot;50200207182018070300011301001&quot;,</span></span><br><span class="line"><span class="comment">          &quot;out_refund_no&quot;: &quot;7752501201407033233368018&quot;,</span></span><br><span class="line"><span class="comment">          &quot;refund_status&quot;: &quot;SUCCESS&quot;,</span></span><br><span class="line"><span class="comment">          &quot;success_time&quot;: &quot;2018-06-08T10:34:56+08:00&quot;,</span></span><br><span class="line"><span class="comment">          &quot;user_received_account&quot;: &quot;招商银行信用卡0403&quot;,</span></span><br><span class="line"><span class="comment">          &quot;amount&quot; : &#123;</span></span><br><span class="line"><span class="comment">              &quot;total&quot;: 999,</span></span><br><span class="line"><span class="comment">              &quot;refund&quot;: 999,</span></span><br><span class="line"><span class="comment">              &quot;payer_total&quot;: 999,</span></span><br><span class="line"><span class="comment">              &quot;payer_refund&quot;: 999</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  已经得到了明文，接下来就可以按照项目逻辑进行处理</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;微信退款V3版本&quot;&gt;&lt;a href=&quot;#微信退款V3版本&quot; class=&quot;headerlink&quot; title=&quot;微信退款V3版本&quot;&gt;&lt;/a&gt;微信退款V3版本&lt;/h1&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t</summary>
      
    
    
    
    <category term="微信退款V3版本" scheme="https://cxmblog.top/categories/%E5%BE%AE%E4%BF%A1%E9%80%80%E6%AC%BEV3%E7%89%88%E6%9C%AC/"/>
    
    
    <category term="微信退款V3版本" scheme="https://cxmblog.top/tags/%E5%BE%AE%E4%BF%A1%E9%80%80%E6%AC%BEV3%E7%89%88%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Base64</title>
    <link href="https://cxmblog.top/2022/06/01/Base64/"/>
    <id>https://cxmblog.top/2022/06/01/Base64/</id>
    <published>2022-06-01T14:46:27.367Z</published>
    <updated>2022-06-17T13:28:09.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Base64-是什么？"><a href="#Base64-是什么？" class="headerlink" title="Base64 是什么？"></a>Base64 是什么？</h2><p>它是一种编码格式，可以将二进制数据进行编码，表示为文本格式。</p><p>Base64编码可以把任意长度的二进制数据变为纯文本，且只包含<code>A~Z、a~z、0~9、+、/、= </code>这些字符。它的原理是把3字节的二进制数据按6bit一组，用4个int整数表示，然后查表，把int整数用索引对应到字符，得到编码后的字符串。</p><p>因为6位整数的范围总是<code> 0~63，所以，能用64个字符表示：字符A~Z 对应索引 0~25 ，字符 a~z 对应索引 26~51 ，字符 0~9 对应索引 52~61，最后两个索引 62、63 分别用字符 + 和 / 表示。</code>这也是Base64名称的来源。</p><h2 id="Base64如何转换"><a href="#Base64如何转换" class="headerlink" title="Base64如何转换"></a>Base64如何转换</h2><p>举个🌰：3个byte数据分别是<code>e4</code>、<code>b8</code>、<code>ad</code>，按6bit分组得到<code>39</code>、<code>0b</code>、<code>22</code>和<code>2d</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────┬───────────────┬───────────────┐</span><br><span class="line">│      e4       │      b8       │      ad       │</span><br><span class="line">└───────────────┴───────────────┴───────────────┘</span><br><span class="line">┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐</span><br><span class="line">│1│1│1│0│0│1│0│0│1│0│1│1│1│0│0│0│1│0│1│0│1│1│0│1│</span><br><span class="line">└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘</span><br><span class="line">┌───────────┬───────────┬───────────┬───────────┐</span><br><span class="line">│    39     │    0b     │    22     │    2d     │</span><br><span class="line">└───────────┴───────────┴───────────┴───────────┘</span><br></pre></td></tr></table></figure><p>如果输入的<code>byte[]</code>数组长度不是3的整数倍肿么办？这种情况下，需要对输入的末尾（低位）补一个或两个<code>0x00</code>（一个十六进制数最多占4bit，0x00占2bit），编码后，在结尾加一个<code>=</code>表示补充了1个<code>0x00</code>，加两个<code>=</code>表示补充了2个<code>0x00</code>，解码的时候，去掉末尾补充的一个或两个<code>0x00</code>即可。</p><p>举个🌰：此时只有两个字节（用**表示补的一个0x00）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────┬───────────────┬───────────────┐</span><br><span class="line">│      e4       │      b8       │               │</span><br><span class="line">└───────────────┴───────────────┴───────────────┘</span><br><span class="line">┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐</span><br><span class="line">│1│1│1│0│0│1│0│0│1│0│1│1│1│0│0│0│*│*│ │ │ │ │ │ │</span><br><span class="line">└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘</span><br><span class="line">┌───────────┬───────────┬───────────┬───────────┐</span><br><span class="line">│    39     │    0b     │    20     │    =      │</span><br><span class="line">└───────────┴───────────┴───────────┴───────────┘</span><br></pre></td></tr></table></figure><p>举个🌰：此时只有一个字节（用**表示补的一个0x00）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────┬───────────────┬───────────────┐</span><br><span class="line">│      e4       │               │               │</span><br><span class="line">└───────────────┴───────────────┴───────────────┘</span><br><span class="line">┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐</span><br><span class="line">│1│1│1│0│0│1│0│0│*│*│*│*│ │ │ │ │ │ │ │ │ │ │ │ │</span><br><span class="line">└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘</span><br><span class="line">┌───────────┬───────────┬───────────┬───────────┐</span><br><span class="line">│    39     │    0      │     =     │    =      │</span><br><span class="line">└───────────┴───────────┴───────────┴───────────┘</span><br></pre></td></tr></table></figure><p>仅用来记录所学，资料来源于<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304227703947297">廖大</a>,<a href="https://zhuanlan.zhihu.com/p/339477329">刘志军大佬</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Base64-是什么？&quot;&gt;&lt;a href=&quot;#Base64-是什么？&quot; class=&quot;headerlink&quot; title=&quot;Base64 是什么？&quot;&gt;&lt;/a&gt;Base64 是什么？&lt;/h2&gt;&lt;p&gt;它是一种编码格式，可以将二进制数据进行编码，表示为文本格式。&lt;/p&gt;</summary>
      
    
    
    
    <category term="java" scheme="https://cxmblog.top/categories/java/"/>
    
    
    <category term="Java基础学习" scheme="https://cxmblog.top/tags/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>类与对象</title>
    <link href="https://cxmblog.top/2022/05/29/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>https://cxmblog.top/2022/05/29/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-05-29T12:32:45.290Z</published>
    <updated>2022-06-01T14:50:54.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类，也是一种数据类型，只不过是我们自定义的"><a href="#类，也是一种数据类型，只不过是我们自定义的" class="headerlink" title="类，也是一种数据类型，只不过是我们自定义的"></a>类，也是一种数据类型，只不过是我们自定义的</h1><p><strong>类是一种引用数据类型，感觉和同为引用数据类型的 数组 很相似，我自己把类理解为一种更高级的数组。</strong></p><span id="more"></span><p>不过数组呢，只能存放同一数据类型的数据，想要取得数组中的一个值，那就需要先去获得这个值对应的下标，通过arr[index]这种方式去获得想要拿到的值，很是麻烦，于是有个类的出现。</p><p>类，一种自定义的数据类型，跟八大基本数据类型以及引用数据类型中的数组有相似的创建方式，比如 int[] arr &#x3D; new int[length];String[] str &#x3D; new String[length];通过new关键字就可以创建一个对象。</p><p>类可以按照我我们的需求来存放多种数据类型，访问某一个属性的值只需要知道该属性的名称就可以，通过 <strong>类名.属性名</strong>就可以取到对应的值。</p><h1 id="对象在jvm内存中的表现方式"><a href="#对象在jvm内存中的表现方式" class="headerlink" title="对象在jvm内存中的表现方式"></a>对象在jvm内存中的表现方式</h1><p><img src="https://blog-images-blog.oss-cn-beijing.aliyuncs.com/images/202205300857670.png" alt="image-20210516134101648"></p><p>1，当我们执行Cat cat &#x3D; new Cat(); 的时候，首先会在方法区里边去加载Cat类的信息（如果是第一次创建Cat对象的话，如果之前就已经创建过Cat对象，那就不会再重复加载，<strong>方法区中的类的信息只会加载一次</strong>）。</p><p>2，在<strong>堆</strong>中开辟对象的空间，进行默认的初始化，赋初值，返回该对象的地址给到 <strong>栈</strong>中的 对象名cat。</p><p>3，进行自定义值的初始化。</p><h1 id="继承的内存布局"><a href="#继承的内存布局" class="headerlink" title="继承的内存布局"></a>继承的内存布局</h1><p><img src="https://blog-images-blog.oss-cn-beijing.aliyuncs.com/images/202205300857038.png" alt="image-20210521122853323"></p><h1 id="java-的动态绑定机制"><a href="#java-的动态绑定机制" class="headerlink" title="java 的动态绑定机制"></a>java 的动态绑定机制</h1><p><img src="https://blog-images-blog.oss-cn-beijing.aliyuncs.com/images/202205300857767.png" alt="image-20210521131648871"></p><p><strong>ps: <strong>如果我把子类B中的sum（）方法注释掉，那么在执行a.sum（）方法的时候，程序会首先去B类的方法区去找，因为注销了，找不到就回根据继承关系去找B的父类A，在A类中找到该方法，就开始执行，这个时候，发现A类的sum()方法调用了getI()方法，</strong>这个时候，就会根据动态绑定机制，就会先去运行时类型的对象的方法区去找有没有getI()方法，找到了就会返回当前所在类的属性的值（因为当对象调用属性的时候，属性没有动态绑定机制，在哪里声明就会在哪里使用）。</strong></p><h1 id="当子类跟父类没有重复的属性值的时候，就可以直接调用父类可以访问的方法去给自己的属性进行赋值以及显示信息"><a href="#当子类跟父类没有重复的属性值的时候，就可以直接调用父类可以访问的方法去给自己的属性进行赋值以及显示信息" class="headerlink" title="当子类跟父类没有重复的属性值的时候，就可以直接调用父类可以访问的方法去给自己的属性进行赋值以及显示信息"></a>当子类跟父类没有重复的属性值的时候，就可以直接调用父类可以访问的方法去给自己的属性进行赋值以及显示信息</h1><p><img src="https://blog-images-blog.oss-cn-beijing.aliyuncs.com/images/202205300857044.png" alt="image-20210521140915612"></p><p><img src="https://blog-images-blog.oss-cn-beijing.aliyuncs.com/images/202205300857220.png" alt="image-20210521140615080"></p><p><img src="https://blog-images-blog.oss-cn-beijing.aliyuncs.com/images/202205300857855.png" alt="image-20210521140521928"></p><p>Manager子类重写了Employee父类的getAnnual()方法，这里Manager子类使用<strong>super.getAnnual() + this.bonus;<strong>方式，当程序定位到父类的getAnnual()方法时，这个时候发现有一个getSalary() * 12 ，那根据动态绑定机制，就会先去找一找</strong>运行时对象</strong>的方法区有没有这个getSalary()方法，有的话就把<strong>运行时对象的属性值</strong>返回，进行计算，计算完成后返回调用位置继续执行下一步的拼接计算。</p><p><strong>我做了一个小测试，在子类Manager中添加了一个跟父类Employee中同名同类型的属性，name,  当我在子类中没有写name属性的getter,setter方法的时候，当我用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showEmpAnnual</span><span class="params">(Employee e)</span>&#123;<span class="comment">//实现获取任何员工对象的年工资</span></span><br><span class="line">    System.out.println(e.getName() + <span class="string">&quot;的年度薪水是：\t&quot;</span> + e.getAnnual());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>e.getName()去获取传进来的名字的时候，会打印输出 <strong>总经理</strong>，当我在子类中写name属性的getter,setter方法的时候（这个时候相当于重写了父类的getter，setter方法），再用e.getName()去获取传进来的名字的时候，会打印输出 <strong>Manager</strong>。</p><p>这个结果证实了两件事：</p><p><strong>1，确实有动态绑定机制的存在，程序执行的时候，会先从运行时对象的方法区去找有没有某个方法，有的话就调用这个方法以及根据这个方法所在类的属性值进行计算等一系列操作，如果没有在运行时对象的方法区中找到，则会继续往它的父类开始找，在父类中找到了则会调用父类的方法以及父类的属性值进行计算。（如果在父类的方法中需要调用其他的方法做进一步操作，还是会根据动态绑定机制，先去看看子类中有没有这个方法）</strong></p><p><strong>2，对于两个有继承关系的父子类，子类可以使用父类的属性，但这并不代表子类具有这些属性，子类有的仅仅是自己定义的属性。就比如你可以用你父亲的东西允许你使用，你想怎么用就怎么用，在外人眼里，你拥有的就是你父亲的东西加上你自己的东西，但是你却明白自己拥有的还只是自己那些东西</strong></p><p><img src="https://blog-images-blog.oss-cn-beijing.aliyuncs.com/images/202205300857240.png" alt="image-20210521144200132"></p><h1 id="编写代码是能调用哪些属性和方法，需要看编译类型是什么"><a href="#编写代码是能调用哪些属性和方法，需要看编译类型是什么" class="headerlink" title="编写代码是能调用哪些属性和方法，需要看编译类型是什么"></a>编写代码是能调用哪些属性和方法，需要看编译类型是什么</h1><p><img src="https://blog-images-blog.oss-cn-beijing.aliyuncs.com/images/202205300857296.png" alt="image-20210525221811045"></p><p><strong>编写代码是能调用哪些属性和方法，需要看编译类型是什么</strong></p><p><strong>当我们在运行代码的时候，具体访问的是哪些方法和属性就需要看运行时类型（存在动态绑定，先从子类找，子类没有就往父类找）</strong></p><h1 id="访问控制符的访问权限"><a href="#访问控制符的访问权限" class="headerlink" title="访问控制符的访问权限"></a>访问控制符的访问权限</h1><p><img src="https://blog-images-blog.oss-cn-beijing.aliyuncs.com/images/202205300857730.png" alt="image-20210526102419136"></p><p><strong>ps:如果子类和父类在同一包下，那default访问控制符修饰的父子类是可以访问的</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;类，也是一种数据类型，只不过是我们自定义的&quot;&gt;&lt;a href=&quot;#类，也是一种数据类型，只不过是我们自定义的&quot; class=&quot;headerlink&quot; title=&quot;类，也是一种数据类型，只不过是我们自定义的&quot;&gt;&lt;/a&gt;类，也是一种数据类型，只不过是我们自定义的&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;类是一种引用数据类型，感觉和同为引用数据类型的 数组 很相似，我自己把类理解为一种更高级的数组。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://cxmblog.top/categories/java/"/>
    
    
    <category term="Java基础学习" scheme="https://cxmblog.top/tags/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>小细节</title>
    <link href="https://cxmblog.top/2022/05/29/%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <id>https://cxmblog.top/2022/05/29/%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</id>
    <published>2022-05-29T12:32:39.328Z</published>
    <updated>2022-06-01T14:48:38.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>1，static代码块也叫做静态代码块，作用就是对类进行初始化，而且它是随着<strong>类的加载</strong>而执行，并且<strong>只会执行一次</strong>。如果是普通代码块，则每创建一个新的对象，就会执行一次。</p><p>2，类 什么时候被加载</p><p>​（1）创建对象实例的时候（new）</p><p>​（2）创建子类对象实例，父类也会被加载</p><p>​（3）使用类的静态成员的时候（静态属性，静态方法）</p><p>3，普通代码块，在创建对象实例的时候，会被隐式调用。被创建一次，就会调用一次。如果只是使用类的静态成员的时候，普通代码块并不会被执行。</p><span id="more"></span><p>4，在创建一个对象的时候，在一个类的调用顺序是：</p><p>​（1）调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化调用的优先级是一样的，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用）</p><p>​（2）调用普通代码块和普通属性初始化 （注意：普通代码块和普通属性初始化调用的优先级是一样的，如果有多个普通代码块和多个普通变量初始化，则按他们定义的顺序调用）</p><p>​（3）调用构造方法</p><p>5，构造器最前边隐藏了super()和调用普通代码块以及普通属性初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//super();</span></span><br><span class="line">        <span class="comment">//调用普通代码块以及普通属性初始化</span></span><br><span class="line">        System.out.println(<span class="string">&quot;A 构造器被调用....&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6，我们看一下创建一个子类对象时，他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造器的调用顺序</p><p>​（1）先加载类信息到方法区，所以会先执行父类静态代码块，静态属性初始化（优先级一样，按定义顺序调用）</p><p>​（2）执行子类静态代码块，静态属性初始化（优先级一样，按定义顺序调用）</p><p>​（3）父类的普通代码块，普通属性初始化（优先级一样，按定义顺序调用）</p><p>​（4）父类构造器执行完毕</p><p>​（5）子类的普通代码块，普通属性初始化（优先级一样，按定义顺序调用）</p><p>​（6）子类构造器执行完毕</p><p>7，静态代码块只能调用静态成员（静态属性，静态方法），普通代码块可以调用任意成员</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sample 静态代码块...&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sample 普通代码块...&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    Sample(String s) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    Sample() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sample 空参构造器被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CodeStaticTest01</span> &#123;</span><br><span class="line">    <span class="type">Sample</span> <span class="variable">sam1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sample</span>(<span class="string">&quot;sam1 普通属性初始化...&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Sample</span> <span class="variable">sam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sample</span>(<span class="string">&quot;CodeStaticTest01 的静态 sam 属性初始化....&quot;</span>);</span><br><span class="line"><span class="comment">//    static int sum = 0;</span></span><br><span class="line"><span class="comment">//    static String name = &quot;tom&quot;;    静态属性初始化可以是一个具体的值，也可以赋值为一个对象的地址</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CodeStaticTest01 的静态代码块....&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    CodeStaticTest01() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CodeStaticTest01 的空参构造器....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CodeStaticTest01</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CodeStaticTest01</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://blog-images-blog.oss-cn-beijing.aliyuncs.com/images/202205300900894.png" alt="image-20210526224018099"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;代码块&quot;&gt;&lt;a href=&quot;#代码块&quot; class=&quot;headerlink&quot; title=&quot;代码块&quot;&gt;&lt;/a&gt;代码块&lt;/h1&gt;&lt;p&gt;1，static代码块也叫做静态代码块，作用就是对类进行初始化，而且它是随着&lt;strong&gt;类的加载&lt;/strong&gt;而执行，并且&lt;strong&gt;只会执行一次&lt;/strong&gt;。如果是普通代码块，则每创建一个新的对象，就会执行一次。&lt;/p&gt;
&lt;p&gt;2，类 什么时候被加载&lt;/p&gt;
&lt;p&gt;​	（1）创建对象实例的时候（new）&lt;/p&gt;
&lt;p&gt;​	（2）创建子类对象实例，父类也会被加载&lt;/p&gt;
&lt;p&gt;​	（3）使用类的静态成员的时候（静态属性，静态方法）&lt;/p&gt;
&lt;p&gt;3，普通代码块，在创建对象实例的时候，会被隐式调用。被创建一次，就会调用一次。如果只是使用类的静态成员的时候，普通代码块并不会被执行。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://cxmblog.top/categories/java/"/>
    
    
    <category term="Java基础学习" scheme="https://cxmblog.top/tags/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>你问我答</title>
    <link href="https://cxmblog.top/2022/05/29/%E4%BD%A0%E9%97%AE%E6%88%91%E7%AD%94/"/>
    <id>https://cxmblog.top/2022/05/29/%E4%BD%A0%E9%97%AE%E6%88%91%E7%AD%94/</id>
    <published>2022-05-29T12:32:22.168Z</published>
    <updated>2022-06-01T14:48:35.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是多态？多态的具体表现有哪些？"><a href="#什么是多态？多态的具体表现有哪些？" class="headerlink" title="什么是多态？多态的具体表现有哪些？"></a>什么是多态？多态的具体表现有哪些？</h1><p>多态：方法或者对象具有多种形态，是OOP的第三大特征，建立在封装和继承基础上。</p><p>具体表现：</p><p>1，方法多态</p><p>​（1）重载体现多态</p><p>​（2）重写体现多态</p><p>2，对象的多态</p><p>​（1)对象的编译类型和运行类型可以不一致，编译类型在定义的时候就已经确定了，不可改变</p><p>​（2）对象的运行类型是可以变化的，可以通过getClass（）来查看运行类型</p><p><img src="https://blog-images-blog.oss-cn-beijing.aliyuncs.com/images/202205300901701.png" alt="image-20210526140537402"></p><p>​（3） 编译类型看定义时 &#x3D; 号 左边，运行类型看 &#x3D; 号 右边</p><h1 id="java的动态绑定机制是什么？"><a href="#java的动态绑定机制是什么？" class="headerlink" title="java的动态绑定机制是什么？"></a>java的动态绑定机制是什么？</h1><p>1，当调用对象的方法的时候，该方法会和对象的内存地址&#x2F;运行类型绑定</p><p>2，当调用对象的属性的时候，没有动态绑定机制，哪里声明，哪里使用。</p><h1 id="Tomcat-跟-Nginx-是什么？有什么用？有什么区别？为什么要用它们？"><a href="#Tomcat-跟-Nginx-是什么？有什么用？有什么区别？为什么要用它们？" class="headerlink" title="Tomcat 跟 Nginx 是什么？有什么用？有什么区别？为什么要用它们？"></a>Tomcat 跟 Nginx 是什么？有什么用？有什么区别？为什么要用它们？</h1><p>Nginx和Tomcat两者应用领域不一样，tomcat是做java语言的动态解析，而nginx则是一款功能强大的负载软件，配合各种插件可以实现各种功能。</p><p>Nginx是一款轻量级的Web 服务器&#x2F;反向代理服务器及电子邮件（IMAP&#x2F;POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好。</p><p>Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。实际上Tomcat 部分是Apache 服务器的扩展，但它是独立运行的，所以当你运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。</p><p><strong>Tomcat和Nginx的区别</strong></p><p>1、从应用方面</p><p>tomcat一般是做动态解析才会用得到，支持jsp的解析，需要配置JDK支持。</p><p>nginx，则一般是做静态，本身不具备动态解析功能，需要配置其他插件或通过其他软件协同才具备动态功能，比如php，tomcat，或者proxypass到win2008的iis服务器做ASP的动态链接等，但nginx在静态上的功能非常强大，也可做访问控制，而且可以做成各种协议负载服务器，包括流媒体的也可以做，具体得去官方网站去看；</p><p>2、在性能方面</p><p>如果再不做系统调优的情况下，tomcat一般支持并发并不高100个差不多了；nginx在静态方面支持并发轻松达几万。</p><p>如果你学过html，css，你会知道你写的页面只能自己访问，<strong>别人不能远程访问你写的页面</strong>，Tomcat就是<strong>提供能够让别人访问自己写的页面的一个程序</strong></p><p><strong>自己的理解：即使知道服务器的IP地址，客户端向这个ip发送请求，也就仅仅是请求，服务端收到后也并不会做出反应，但是如果这个请求让Tomcat或者Nginx获取到了，通过他们的处理（包括但不限于跟数据库交互、直接计算返回结果等等），来完成客户端的请求并且把服务器端处理后的信息返回给客户端进行显示，这样就完成了客户端跟服务器端的交互。</strong></p><h1 id="抽象类跟接口是什么？有什么区别？"><a href="#抽象类跟接口是什么？有什么区别？" class="headerlink" title="抽象类跟接口是什么？有什么区别？"></a>抽象类跟接口是什么？有什么区别？</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是多态？多态的具体表现有哪些？&quot;&gt;&lt;a href=&quot;#什么是多态？多态的具体表现有哪些？&quot; class=&quot;headerlink&quot; title=&quot;什么是多态？多态的具体表现有哪些？&quot;&gt;&lt;/a&gt;什么是多态？多态的具体表现有哪些？&lt;/h1&gt;&lt;p&gt;多态：方法或者对象具</summary>
      
    
    
    
    <category term="java" scheme="https://cxmblog.top/categories/java/"/>
    
    
    <category term="Java基础学习" scheme="https://cxmblog.top/tags/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
