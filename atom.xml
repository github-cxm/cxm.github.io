<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>师傅打妖怪啦</title>
  
  
  <link href="https://cxmblog.top/atom.xml" rel="self"/>
  
  <link href="https://cxmblog.top/"/>
  <updated>2022-05-29T15:40:35.729Z</updated>
  <id>https://cxmblog.top/</id>
  
  <author>
    <name>CXM</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>运算符</title>
    <link href="https://cxmblog.top/2022/05/29/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://cxmblog.top/2022/05/29/%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2022-05-29T12:32:50.795Z</published>
    <updated>2022-05-29T15:40:35.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="取余（取模）运算符"><a href="#取余（取模）运算符" class="headerlink" title="取余（取模）运算符%"></a>取余（取模）运算符%</h1><h3 id="取余运算的结果会根据公式：-a-a-x2F-b-x-b-得到"><a href="#取余运算的结果会根据公式：-a-a-x2F-b-x-b-得到" class="headerlink" title="取余运算的结果会根据公式： a - a &#x2F; b x b  得到"></a>取余运算的结果会根据公式： a - a &#x2F; b x b  得到</h3><p><img src="/image-20210513101206529.png" alt="image-20210513101206529"></p><span id="more"></span><p>**注意： a % b ,当 a 是小数的时候，公式： a - (itn)a &#x2F; b x b **</p><p><img src="/image-20210513154539151.png" alt="image-20210513154539151"></p><p>**&#x3D;&#x3D;&gt;**当有小数参与运算得到的结果，是一个近似值</p><h1 id="自增运算符-（-–）"><a href="#自增运算符-（-–）" class="headerlink" title="自增运算符 （++–）"></a>自增运算符 （++–）</h1><p><strong>++  作为独立语句的时候，完全等价于 i &#x3D; i + 1;</strong></p><p><strong>++  作为表达式使用的时候， ++i 先自增后赋值， i++ 先赋值后自增</strong></p><p><strong>– 同理</strong></p><p><img src="/image-20210513102833957.png" alt="image-20210513102833957"></p><p><strong>注意：</strong></p><p><img src="/image-20210513104523995.png" alt="image-20210513104523995"></p><p>!<img src="/image-20210513105100451.png" alt="image-20210513105100451"></p><p><img src="/image-20210513105813835.png" alt="image-20210513105813835"></p><h1 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h1><p><img src="/image-20210513115101278.png" alt="image-20210513115101278"></p><h1 id="源码-反码-补码"><a href="#源码-反码-补码" class="headerlink" title="源码 反码 补码"></a>源码 反码 补码</h1><p><img src="/image-20210513150414488.png" alt="image-20210513150414488"></p><p><strong>位预算符的运算规则</strong></p><p><img src="/image-20210513153636084.png" alt="image-20210513153636084"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;取余（取模）运算符&quot;&gt;&lt;a href=&quot;#取余（取模）运算符&quot; class=&quot;headerlink&quot; title=&quot;取余（取模）运算符	%&quot;&gt;&lt;/a&gt;取余（取模）运算符	%&lt;/h1&gt;&lt;h3 id=&quot;取余运算的结果会根据公式：-a-a-x2F-b-x-b-得到&quot;&gt;&lt;a href=&quot;#取余运算的结果会根据公式：-a-a-x2F-b-x-b-得到&quot; class=&quot;headerlink&quot; title=&quot;取余运算的结果会根据公式： a - a &amp;#x2F; b x b  得到&quot;&gt;&lt;/a&gt;取余运算的结果会根据公式： a - a &amp;#x2F; b x b  得到&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/image-20210513101206529.png&quot; alt=&quot;image-20210513101206529&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://cxmblog.top/categories/java/"/>
    
    
    <category term="Java基础学习" scheme="https://cxmblog.top/tags/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>类与对象</title>
    <link href="https://cxmblog.top/2022/05/29/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>https://cxmblog.top/2022/05/29/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-05-29T12:32:45.290Z</published>
    <updated>2022-05-29T15:37:03.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类，也是一种数据类型，只不过是我们自定义的"><a href="#类，也是一种数据类型，只不过是我们自定义的" class="headerlink" title="类，也是一种数据类型，只不过是我们自定义的"></a>类，也是一种数据类型，只不过是我们自定义的</h1><p><strong>类是一种引用数据类型，感觉和同为引用数据类型的 数组 很相似，我自己把类理解为一种更高级的数组。</strong></p><span id="more"></span><p>不过数组呢，只能存放同一数据类型的数据，想要取得数组中的一个值，那就需要先去获得这个值对应的下标，通过arr[index]这种方式去获得想要拿到的值，很是麻烦，于是有个类的出现。</p><p>类，一种自定义的数据类型，跟八大基本数据类型以及引用数据类型中的数组有相似的创建方式，比如 int[] arr &#x3D; new int[length];String[] str &#x3D; new String[length];通过new关键字就可以创建一个对象。</p><p>类可以按照我我们的需求来存放多种数据类型，访问某一个属性的值只需要知道该属性的名称就可以，通过 <strong>类名.属性名</strong>就可以取到对应的值。</p><h1 id="对象在jvm内存中的表现方式"><a href="#对象在jvm内存中的表现方式" class="headerlink" title="对象在jvm内存中的表现方式"></a>对象在jvm内存中的表现方式</h1><p><img src="/image-20210516134101648.png" alt="image-20210516134101648"></p><p>1，当我们执行Cat cat &#x3D; new Cat(); 的时候，首先会在方法区里边去加载Cat类的信息（如果是第一次创建Cat对象的话，如果之前就已经创建过Cat对象，那就不会再重复加载，<strong>方法区中的类的信息只会加载一次</strong>）。</p><p>2，在<strong>堆</strong>中开辟对象的空间，进行默认的初始化，赋初值，返回该对象的地址给到 <strong>栈</strong>中的 对象名cat。</p><p>3，进行自定义值的初始化。</p><h1 id="继承的内存布局"><a href="#继承的内存布局" class="headerlink" title="继承的内存布局"></a>继承的内存布局</h1><p><img src="/image-20210521122853323.png" alt="image-20210521122853323"></p><h1 id="java-的动态绑定机制"><a href="#java-的动态绑定机制" class="headerlink" title="java 的动态绑定机制"></a>java 的动态绑定机制</h1><p><img src="/image-20210521131648871.png" alt="image-20210521131648871"></p><p><strong>ps: <strong>如果我把子类B中的sum（）方法注释掉，那么在执行a.sum（）方法的时候，程序会首先去B类的方法区去找，因为注销了，找不到就回根据继承关系去找B的父类A，在A类中找到该方法，就开始执行，这个时候，发现A类的sum()方法调用了getI()方法，</strong>这个时候，就会根据动态绑定机制，就会先去运行时类型的对象的方法区去找有没有getI()方法，找到了就会返回当前所在类的属性的值（因为当对象调用属性的时候，属性没有动态绑定机制，在哪里声明就会在哪里使用）。</strong></p><h1 id="当子类跟父类没有重复的属性值的时候，就可以直接调用父类可以访问的方法去给自己的属性进行赋值以及显示信息"><a href="#当子类跟父类没有重复的属性值的时候，就可以直接调用父类可以访问的方法去给自己的属性进行赋值以及显示信息" class="headerlink" title="当子类跟父类没有重复的属性值的时候，就可以直接调用父类可以访问的方法去给自己的属性进行赋值以及显示信息"></a>当子类跟父类没有重复的属性值的时候，就可以直接调用父类可以访问的方法去给自己的属性进行赋值以及显示信息</h1><p><img src="/image-20210521140915612.png" alt="image-20210521140915612"></p><p><img src="/image-20210521140615080.png" alt="image-20210521140615080"></p><p><img src="/image-20210521140521928.png" alt="image-20210521140521928"></p><p>Manager子类重写了Employee父类的getAnnual()方法，这里Manager子类使用<strong>super.getAnnual() + this.bonus;<strong>方式，当程序定位到父类的getAnnual()方法时，这个时候发现有一个getSalary() * 12 ，那根据动态绑定机制，就会先去找一找</strong>运行时对象</strong>的方法区有没有这个getSalary()方法，有的话就把<strong>运行时对象的属性值</strong>返回，进行计算，计算完成后返回调用位置继续执行下一步的拼接计算。</p><p><strong>我做了一个小测试，在子类Manager中添加了一个跟父类Employee中同名同类型的属性，name,  当我在子类中没有写name属性的getter,setter方法的时候，当我用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showEmpAnnual</span><span class="params">(Employee e)</span>&#123;<span class="comment">//实现获取任何员工对象的年工资</span></span><br><span class="line">    System.out.println(e.getName() + <span class="string">&quot;的年度薪水是：\t&quot;</span> + e.getAnnual());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>e.getName()去获取传进来的名字的时候，会打印输出 <strong>总经理</strong>，当我在子类中写name属性的getter,setter方法的时候（这个时候相当于重写了父类的getter，setter方法），再用e.getName()去获取传进来的名字的时候，会打印输出 <strong>Manager</strong>。</p><p>这个结果证实了两件事：</p><p><strong>1，确实有动态绑定机制的存在，程序执行的时候，会先从运行时对象的方法区去找有没有某个方法，有的话就调用这个方法以及根据这个方法所在类的属性值进行计算等一系列操作，如果没有在运行时对象的方法区中找到，则会继续往它的父类开始找，在父类中找到了则会调用父类的方法以及父类的属性值进行计算。（如果在父类的方法中需要调用其他的方法做进一步操作，还是会根据动态绑定机制，先去看看子类中有没有这个方法）</strong></p><p><strong>2，对于两个有继承关系的父子类，子类可以使用父类的属性，但这并不代表子类具有这些属性，子类有的仅仅是自己定义的属性。就比如你可以用你父亲的东西允许你使用，你想怎么用就怎么用，在外人眼里，你拥有的就是你父亲的东西加上你自己的东西，但是你却明白自己拥有的还只是自己那些东西</strong></p><p><img src="/image-20210521144200132.png" alt="image-20210521144200132"></p><h1 id="编写代码是能调用哪些属性和方法，需要看编译类型是什么"><a href="#编写代码是能调用哪些属性和方法，需要看编译类型是什么" class="headerlink" title="编写代码是能调用哪些属性和方法，需要看编译类型是什么"></a>编写代码是能调用哪些属性和方法，需要看编译类型是什么</h1><p><img src="/image-20210525221811045.png" alt="image-20210525221811045"></p><p><strong>编写代码是能调用哪些属性和方法，需要看编译类型是什么</strong></p><p><strong>当我们在运行代码的时候，具体访问的是哪些方法和属性就需要看运行时类型（存在动态绑定，先从子类找，子类没有就往父类找）</strong></p><h1 id="访问控制符的访问权限"><a href="#访问控制符的访问权限" class="headerlink" title="访问控制符的访问权限"></a>访问控制符的访问权限</h1><p><img src="/image-20210526102419136.png" alt="image-20210526102419136"></p><p><strong>ps:如果子类和父类在同一包下，那default访问控制符修饰的父子类是可以访问的</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;类，也是一种数据类型，只不过是我们自定义的&quot;&gt;&lt;a href=&quot;#类，也是一种数据类型，只不过是我们自定义的&quot; class=&quot;headerlink&quot; title=&quot;类，也是一种数据类型，只不过是我们自定义的&quot;&gt;&lt;/a&gt;类，也是一种数据类型，只不过是我们自定义的&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;类是一种引用数据类型，感觉和同为引用数据类型的 数组 很相似，我自己把类理解为一种更高级的数组。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://cxmblog.top/categories/java/"/>
    
    
    <category term="Java基础学习" scheme="https://cxmblog.top/tags/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>小细节</title>
    <link href="https://cxmblog.top/2022/05/29/%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <id>https://cxmblog.top/2022/05/29/%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</id>
    <published>2022-05-29T12:32:39.328Z</published>
    <updated>2022-05-29T15:02:51.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>1，static代码块也叫做静态代码块，作用就是对类进行初始化，而且它是随着<strong>类的加载</strong>而执行，并且<strong>只会执行一次</strong>。如果是普通代码块，则每创建一个新的对象，就会执行一次。</p><p>2，类 什么时候被加载</p><p>​（1）创建对象实例的时候（new）</p><p>​（2）创建子类对象实例，父类也会被加载</p><p>​（3）使用类的静态成员的时候（静态属性，静态方法）</p><p>3，普通代码块，在创建对象实例的时候，会被隐式调用。被创建一次，就会调用一次。如果只是使用类的静态成员的时候，普通代码块并不会被执行。</p><span id="more"></span><p>4，在创建一个对象的时候，在一个类的调用顺序是：</p><p>​（1）调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化调用的优先级是一样的，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用）</p><p>​（2）调用普通代码块和普通属性初始化 （注意：普通代码块和普通属性初始化调用的优先级是一样的，如果有多个普通代码块和多个普通变量初始化，则按他们定义的顺序调用）</p><p>​（3）调用构造方法</p><p>5，构造器最前边隐藏了super()和调用普通代码块以及普通属性初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//super();</span></span><br><span class="line">        <span class="comment">//调用普通代码块以及普通属性初始化</span></span><br><span class="line">        System.out.println(<span class="string">&quot;A 构造器被调用....&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6，我们看一下创建一个子类对象时，他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造器的调用顺序</p><p>​（1）先加载类信息到方法区，所以会先执行父类静态代码块，静态属性初始化（优先级一样，按定义顺序调用）</p><p>​（2）执行子类静态代码块，静态属性初始化（优先级一样，按定义顺序调用）</p><p>​（3）父类的普通代码块，普通属性初始化（优先级一样，按定义顺序调用）</p><p>​（4）父类构造器执行完毕</p><p>​（5）子类的普通代码块，普通属性初始化（优先级一样，按定义顺序调用）</p><p>​（6）子类构造器执行完毕</p><p>7，静态代码块只能调用静态成员（静态属性，静态方法），普通代码块可以调用任意成员</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sample 静态代码块...&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sample 普通代码块...&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    Sample(String s) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    Sample() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sample 空参构造器被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CodeStaticTest01</span> &#123;</span><br><span class="line">    <span class="type">Sample</span> <span class="variable">sam1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sample</span>(<span class="string">&quot;sam1 普通属性初始化...&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Sample</span> <span class="variable">sam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sample</span>(<span class="string">&quot;CodeStaticTest01 的静态 sam 属性初始化....&quot;</span>);</span><br><span class="line"><span class="comment">//    static int sum = 0;</span></span><br><span class="line"><span class="comment">//    static String name = &quot;tom&quot;;    静态属性初始化可以是一个具体的值，也可以赋值为一个对象的地址</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CodeStaticTest01 的静态代码块....&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    CodeStaticTest01() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CodeStaticTest01 的空参构造器....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CodeStaticTest01</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CodeStaticTest01</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/../../../../../../var/folders/nm/7tbjbb810dxd9rlmqjj9gy3r0000gn/T/com.apple.Preview/com.apple.Preview.PasteboardItems/image-20210526224018099.png" alt="image-20210526224018099"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;代码块&quot;&gt;&lt;a href=&quot;#代码块&quot; class=&quot;headerlink&quot; title=&quot;代码块&quot;&gt;&lt;/a&gt;代码块&lt;/h1&gt;&lt;p&gt;1，static代码块也叫做静态代码块，作用就是对类进行初始化，而且它是随着&lt;strong&gt;类的加载&lt;/strong&gt;而执行，并且&lt;strong&gt;只会执行一次&lt;/strong&gt;。如果是普通代码块，则每创建一个新的对象，就会执行一次。&lt;/p&gt;
&lt;p&gt;2，类 什么时候被加载&lt;/p&gt;
&lt;p&gt;​	（1）创建对象实例的时候（new）&lt;/p&gt;
&lt;p&gt;​	（2）创建子类对象实例，父类也会被加载&lt;/p&gt;
&lt;p&gt;​	（3）使用类的静态成员的时候（静态属性，静态方法）&lt;/p&gt;
&lt;p&gt;3，普通代码块，在创建对象实例的时候，会被隐式调用。被创建一次，就会调用一次。如果只是使用类的静态成员的时候，普通代码块并不会被执行。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://cxmblog.top/categories/java/"/>
    
    
    <category term="Java基础学习" scheme="https://cxmblog.top/tags/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>你问我答</title>
    <link href="https://cxmblog.top/2022/05/29/%E4%BD%A0%E9%97%AE%E6%88%91%E7%AD%94/"/>
    <id>https://cxmblog.top/2022/05/29/%E4%BD%A0%E9%97%AE%E6%88%91%E7%AD%94/</id>
    <published>2022-05-29T12:32:22.168Z</published>
    <updated>2022-05-29T13:10:08.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是多态？多态的具体表现有哪些？"><a href="#什么是多态？多态的具体表现有哪些？" class="headerlink" title="什么是多态？多态的具体表现有哪些？"></a>什么是多态？多态的具体表现有哪些？</h1><p>多态：方法或者对象具有多种形态，是OOP的第三大特征，建立在封装和继承基础上。</p><p>具体表现：</p><p>1，方法多态</p><p>​（1）重载体现多态</p><p>​（2）重写体现多态</p><p>2，对象的多态</p><p>​（1)对象的编译类型和运行类型可以不一致，编译类型在定义的时候就已经确定了，不可改变</p><p>​（2）对象的运行类型是可以变化的，可以通过getClass（）来查看运行类型</p><p><img src="https://gitee.com/github-cxm/image/raw/master/image-20210526140537402.png" alt="image-20210526140537402"></p><p>​（3） 编译类型看定义时 &#x3D; 号 左边，运行类型看 &#x3D; 号 右边</p><h1 id="java的动态绑定机制是什么？"><a href="#java的动态绑定机制是什么？" class="headerlink" title="java的动态绑定机制是什么？"></a>java的动态绑定机制是什么？</h1><p>1，当调用对象的方法的时候，该方法会和对象的内存地址&#x2F;运行类型绑定</p><p>2，当调用对象的属性的时候，没有动态绑定机制，哪里声明，哪里使用。</p><h1 id="Tomcat-跟-Nginx-是什么？有什么用？有什么区别？为什么要用它们？"><a href="#Tomcat-跟-Nginx-是什么？有什么用？有什么区别？为什么要用它们？" class="headerlink" title="Tomcat 跟 Nginx 是什么？有什么用？有什么区别？为什么要用它们？"></a>Tomcat 跟 Nginx 是什么？有什么用？有什么区别？为什么要用它们？</h1><p>Nginx和Tomcat两者应用领域不一样，tomcat是做java语言的动态解析，而nginx则是一款功能强大的负载软件，配合各种插件可以实现各种功能。</p><p>Nginx是一款轻量级的Web 服务器&#x2F;反向代理服务器及电子邮件（IMAP&#x2F;POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好。</p><p>Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。实际上Tomcat 部分是Apache 服务器的扩展，但它是独立运行的，所以当你运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。</p><p><strong>Tomcat和Nginx的区别</strong></p><p>1、从应用方面</p><p>tomcat一般是做动态解析才会用得到，支持jsp的解析，需要配置JDK支持。</p><p>nginx，则一般是做静态，本身不具备动态解析功能，需要配置其他插件或通过其他软件协同才具备动态功能，比如php，tomcat，或者proxypass到win2008的iis服务器做ASP的动态链接等，但nginx在静态上的功能非常强大，也可做访问控制，而且可以做成各种协议负载服务器，包括流媒体的也可以做，具体得去官方网站去看；</p><p>2、在性能方面</p><p>如果再不做系统调优的情况下，tomcat一般支持并发并不高100个差不多了；nginx在静态方面支持并发轻松达几万。</p><p>如果你学过html，css，你会知道你写的页面只能自己访问，<strong>别人不能远程访问你写的页面</strong>，Tomcat就是<strong>提供能够让别人访问自己写的页面的一个程序</strong></p><p><strong>自己的理解：即使知道服务器的IP地址，客户端向这个ip发送请求，也就仅仅是请求，服务端收到后也并不会做出反应，但是如果这个请求让Tomcat或者Nginx获取到了，通过他们的处理（包括但不限于跟数据库交互、直接计算返回结果等等），来完成客户端的请求并且把服务器端处理后的信息返回给客户端进行显示，这样就完成了客户端跟服务器端的交互。</strong></p><h1 id="抽象类跟接口是什么？有什么区别？"><a href="#抽象类跟接口是什么？有什么区别？" class="headerlink" title="抽象类跟接口是什么？有什么区别？"></a>抽象类跟接口是什么？有什么区别？</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是多态？多态的具体表现有哪些？&quot;&gt;&lt;a href=&quot;#什么是多态？多态的具体表现有哪些？&quot; class=&quot;headerlink&quot; title=&quot;什么是多态？多态的具体表现有哪些？&quot;&gt;&lt;/a&gt;什么是多态？多态的具体表现有哪些？&lt;/h1&gt;&lt;p&gt;多态：方法或者对象具</summary>
      
    
    
    
    <category term="java" scheme="https://cxmblog.top/categories/java/"/>
    
    
    <category term="Java基础学习" scheme="https://cxmblog.top/tags/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
